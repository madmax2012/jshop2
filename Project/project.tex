\documentclass[paper=a4, fontsize=11pt]{scrartcl}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{cite}
\usepackage{booktabs} % Required for better horizontal rules in tables
\usepackage{multirow}
\usepackage{multicol}
\usepackage{graphicx}

\lstset{
	sensitive=false,    % not case-sensitive
	morecomment=[l]{;;}, % line comment
	alsoletter={:,-},   % consider extra characters
	frame=single,
	numbers=left,
	breaklines=true,
	tabsize=2,
	basicstyle=\footnotesize,
}

\setlength\parindent{0pt}

\title{Project: Storing Groceries @home}
\author{\'{A}ngela Patricia Enr\'{i}quez G\'{o}mez \\
	Ethan Massey \\
	Maximilian Messing}

\begin{document}
	
	\maketitle 
	
 	\section{Introduction} 
 	
 	This project creates plans for storing groceries tasks in the context of RoboCup @home. It uses the java version of the SHOP2 HTN Planner. \\
 	
 	The robot picks up groceries from a table and stores them in a cupboard with 3 shelves. The door of the cupboard is closed at the beginning,
 	and the robot has a tray to carry more than one item at a time.
 	
 	\section{Selection of the Planner}
 
 	SHOP2 (Simple Hierarchical Ordered Planner) is an HTN Planner that uses partial-order forward decomposition. SHOP2 does not require methods to be totally ordered, i.e., the subtasks of a method can have partial orders. Because of this property, SHOP2 can generate plans by interleaving tasks of different methods. Its predecessor SHOP can only handle methods with totally ordered subtasks and thus, is more limited in the plans it can generate. SHOP can overcome this limitation by adding global methods that allow to perform more general actions \cite{Nau2001}, like adding a pick-two-object method instead of just having a pick-one-object method. However, SHOP2 can interleave the tasks of two pick-one-object methods in such a way that it gives the same results as the more global method pick-two-objects \cite{slides}. \\
 	
 	With SHOP2 the knowledge base is easier to build, because it requires less global information. Having more compact knowledge bases makes it faster to generate them and easier to debug them \cite{Nau2001}. In addition, the methods of the SHOP2 planner allow to have a list of preconditions which are evaluated in order of appearance. This feature facilitates the definition of methods, since a method can achieve several decompositions based on the preconditions \cite{Nau2003}. \\
 	
 	Moreover, the SHOP2 algorithm achieved one of the top four awards in the 2002 International Planning Competition \cite{Nau2003}.
 	
 	\section{Installation}
 	
 	The java version of the SHOP2 planner is available in \url{https://github.com/mas-group/jshop2}
 	
 	% TODO
 	
 	During the installation we encountered some challenges like ... 

	
	\section{Solution}
	
	\subsection{Modeling the domain}
	
	We run the four problems using the same domain model. The domain includes the set of operators, methods and axioms used by the planner. We started with a smaller domain for problem 1 and added information as we worked through the rest of the problems. 
	
	Each problem starts with a different compound task as shown in table \ref{table:compund-tasks}.
	
	\begin{table}[h!]
		
	\centering
		
	\begin{tabular}{cl}
		\toprule   
		
		Problem & Task to achieve \\
		\midrule
		
		1 & mode-known-object ?a ?t ?c ?s \\
		
		\midrule
		
		2 & move-known-objects ?t ?c ?s ?tray \\
		
		\midrule
		
		3 & move-uncategorized-objects ?t ?c ?s ?tray ?camera \\
		
		\midrule
		
		4 & move-unlabeled-object-unknown-cupboard ?t ?c ?s ?tray ?camera \\
	
		\bottomrule
	\end{tabular}
	\caption{Tasks to achieve from problems 1 to 4.} 
	\label{table:compund-tasks}
	\end{table}
	
	\subsubsection*{Assumptions:}
	
	The following assumptions were made when writing the domain:
	
	\begin{itemize}
		\item The initial position of the robot is at the table.
		\item All objects on the table should be stored by the robot.
		\item There is only one cupboard.
		\item There is only one table.
		\item The robot uses a tray for carrying objects and the capacity of the tray is infinite. Except for problem 1, where the robot carries only one object using its gripper.
		\item The robot has a camera (problem 3 and 4).
		\item All items should have information that can be used by the robot to classify them (problem 4).		
		\item Each shelf initially holds one object (problem 4).
		\item There is one shelf per object category. 
	\end{itemize}
	
	If the initial state does not follow the assumptions, the planner will fail because the domain does not include operators and/or methods to handle those situations. Section \ref{sec:limitations} discusses some of the limitations of our domain and recommendations on how to adapt it to handle more complex scenarios.
	
	\subsubsection*{Domain}
	
	\begin{lstlisting}		
(defdomain storegroceries
	(
	;;----------------store-groceries operators----------------
	
	;; To pickup an object ?a from a surface (for our domain, the surface is either a shelf of a tray)
	(:operator (!pickup ?a ?s)
		()
		((clear ?a) (on ?a ?s))
		((holding ?a)))
	
	;; To open the cupboard door
	(:operator (!open-door ?d)
		((door-closed ?d))
		((door-closed ?d))
		((door-open ?d)))
	
	;; To putdown an object on a surface (for our domain, the surface is either a shelf of a tray)
	(:operator (!putdown ?a ?s)
		()
		((holding ?a))
		((on ?a ?s) (clear ?a)))
	
	;; To move the robot ?r from location ?x to location ?y
	(:operator (!move ?r ?x ?y)
		((robot-at ?r ?x))
		((robot-at ?r ?x))
		((robot-at ?r ?y)))


	;; To locate an object
	(:operator (!locate ?a)
		((unknown-location ?a))
		((unknown-location ?a))
		((known-location ?a)))
	
	;; To perceive an object with camera ?camera
	(:operator (!perceive ?a ?camera)
		()
		((uncategorized ?a))
		((categorized ?a)))
	
	;; To label an object as a snack
	(:operator (!label-object ?a)
		((is-snack ?a))
		nil
		((snack-label ?a)(labeled ?a)))
		
	;; To label an object as a drink
	(:operator (!label-object ?a)
		((is-drink ?a))
		nil
		((drink-label ?a)(labeled ?a)))

	;; To label an object as a fruit
	(:operator (!label-object ?a)
		((is-fruit ?a))
		nil
		((fruit-label ?a)(labeled ?a)))
	
	;; To label the contents of a shelf. A shelf holds objects of one category
	(:operator (!label-shelf ?s)
		((holds-snack ?s))
		nil
		((snack-label ?s)(labeled ?s)))
	
	(:operator (!label-shelf ?s)
		((holds-drink ?s))
		nil
		((drink-label ?s)(labeled ?s)))

	(:operator (!label-shelf ?s)
		((holds-fruit ?s))
		nil
		((fruit-label ?s)(labeled ?s)))

;;  ---------------store-groceries methods------------------

	;; To move object ?a from the table ?t to the cupboard ?c and place it on shelf ?s
	(:method (move-known-object ?a ?t ?c ?s)
		branch1
		((robot-at ?r ?t)(on ?a ?t)(door-open ?d))
		((!pickup ?a ?t)(!move ?r ?t ?c)(!putdown ?a ?s))
		
		branch2
		((robot-at ?r ?t)(on ?a ?t)(door-closed ?d))
		((!move ?r ?t ?c)(!open-door ?d)(!move ?r ?c ?t)(!pickup ?a ?t)(!move ?r ?t ?c)(!putdown ?a ?s))
	)
	
	;; To locate the table and the cupboard
	(:method (locate-table-and-cupboard ?t ?c)
		()
		((!locate ?t)(!locate ?c))
	)
	
	;; To move objects from the table ?t to the cupboard ?c and place them on shelf ?s, using a ?tray
	(:method (move-known-objects ?t ?c ?s ?tray)
		branch1
		((known-location ?t)(known-location ?c)(robot-at ?r ?t)(door-open ?d))
		((load-tray ?tray ?t)(!move ?r ?t ?c)(unload-tray ?tray ?s))
		
		branch2
		((known-location ?t)(known-location ?c)(robot-at ?r ?t)(door-closed ?d))
		((!move ?r ?t ?c)(!open-door ?d)(!move ?r ?c ?t)(load-tray ?tray ?t)(!move ?r ?t ?c)(unload-tray ?tray ?s))
		
		branch3
		((unknown-location ?t)(unknown-location ?c)(robot-at ?r ?t)(door-open ?d))
		((locate-table-and-cupboard ?t ?c)(load-tray ?tray ?t)(!move ?r ?t ?c)(unload-tray ?tray ?s))
		
		branch4
		((unknown-location ?t)(unknown-location ?c)(robot-at ?r ?t)(door-closed ?d))
		((locate-table-and-cupboard ?t ?c)(!move ?r ?t ?c)(!open-door ?d)(!move ?r ?c ?t)(load-tray ?tray ?t)(!move ?r ?t ?c)(unload-tray ?tray ?s))
	)
	
	;; To move uncategorized objects from the table ?t to the cupboard ?c and place them on shelf ?s, using a ?tray. Objects are perceived using camera ?camera
	(:method (move-uncategorized-objects ?t ?c ?s ?tray ?camera)
		branch1
		((known-location ?t)(known-location ?c)(robot-at ?r ?t)(door-open ?d))
		((categorize ?camera)(load-tray ?tray ?t)(!move ?r ?t ?c)(unload-tray ?tray ?s))
		
		branch2
		((known-location ?t)(known-location ?c)(robot-at ?r ?t)(door-closed ?d))
		((categorize ?camera)(!move ?r ?t ?c)(!open-door ?d)(!move ?r ?c ?t)(load-tray ?tray ?t)(!move ?r ?t ?c)(unload-tray ?tray ?s))
		
		branch3
		((unknown-location ?t)(unknown-location ?c)(robot-at ?r ?t)(door-open ?d))
		((categorize ?camera)(locate-table-and-cupboard ?t ?c)(load-tray ?tray ?t)(!move ?r ?t ?c)(unload-tray ?tray ?s))
		
		branch4
		((unknown-location ?t)(unknown-location ?c)(robot-at ?r ?t)(door-closed ?d))
		((locate-table-and-cupboard ?t ?c)(categorize ?camera)(!move ?r ?t ?c)(!open-door ?d)(!move ?r ?c ?t)(load-tray ?tray ?t)(!move ?r ?t ?c)(unload-tray ?tray ?s))
	)
	
	;; To move unlabeled objects to unknown cupboard
	(:method (move-unlabeled-object-unknown-cupboard ?t ?c ?s ?tray ?camera)
		branch1
		((known-location ?t)(known-location ?c)(robot-at ?r ?t)(door-open ?d))
		((!move ?r ?t ?c)(explore-cupboard ?c)(!move ?r ?c ?t)(label-objects)(load-tray ?tray ?t)(!move ?r ?t ?c)(place-in-shelf ?tray))
		
		branch2
		((known-location ?t)(known-location ?c)(robot-at ?r ?t)(door-closed ?d))
		((!move ?r ?t ?c)(!open-door ?d)(explore-cupboard ?c)(!move ?r ?c ?t)(label-objects)(load-tray ?tray ?t)(!move ?r ?t ?c)(place-in-shelf ?tray))
		
		branch3
		((unknown-location ?t)(unknown-location ?c)(robot-at ?r ?t)(door-open ?d))
		((locate-table-and-cupboard ?t ?c)(!move ?r ?t ?c)(explore-cupboard ?c)(!move ?r ?c ?t)(label-objects)(load-tray ?tray ?t)(!move ?r ?t ?c)(place-in-shelf ?tray))
		
		branch4
		((unknown-location ?t)(unknown-location ?c)(robot-at ?r ?t)(door-closed ?d))
		((locate-table-and-cupboard ?t ?c)(!move ?r ?t ?c)(!open-door ?d)(explore-cupboard ?c)(!move ?r ?c ?t)(label-objects)(load-tray ?tray ?t)(!move ?r ?t ?c)(place-in-shelf ?tray))
	)
	
	;; To place objects on the tray ?tray (so that the robot can carry more than one object at a time). The objects are picked up from the table ?t
	(:method (load-tray ?tray ?t)
		branch1
		((on ?a ?t))
		((!pickup ?a ?t)(!putdown ?a ?tray)(load-tray ?tray ?t))
		branch2
		((not (on ?a ?t)))
		nil  ;do nothing (we are done loading objects)
		)
		
		;; To place all the object from the tray ?tray on the shelf ?s
		(:method (unload-tray ?tray ?s)
		branch1
		((on ?a ?tray))
		((!pickup ?a ?tray)(!putdown ?a ?s)(unload-tray ?tray ?s))
		branch2
		((not (on ?a ?tray)))
		nil  ;do nothing (we are done unloading objects)
	)
	
	;; To place objects from the tray ?tray on the shelf that corresponds to the object category
	(:method (place-in-shelf ?tray)
		; If the object is a snack, choose the shelf labeled as 'snack-label'
		branch1
		((on ?a ?tray)(snack-label ?a)((shelf ?z)(snack-label ?z)))
		((!pickup ?a ?tray)(!putdown ?a ?z)(place-in-shelf ?tray))
		
		; If the object is a drink, choose the shelf labeled as 'drink-label'
		branch2
		((on ?a ?tray)(drink-label ?a)((shelf ?z)(drink-label ?z)))
		((!pickup ?a ?tray)(!putdown ?a ?z)(place-in-shelf ?tray))
		
		; If the object is a fruit, choose the shelf labeled as 'fruit-label'
		branch3
		((on ?a ?tray)(fruit-label ?a)((shelf ?z)(fruit-label ?z)))
		((!pickup ?a ?tray)(!putdown ?a ?z)(place-in-shelf ?tray))
		
		; If there are no more objects on the tray, do nothing
		branch4
		((not (on ?a ?tray)))
		nil  ;do nothing (we are done unloading objects)
	)
	
	;; To perceive and categorize objects
	(:method (categorize ?camera)
		branch1
		(forall (?z) ((object ?z))(categorized ?z))
		nil
		
		branch2
		((object ?z)(uncategorized ?z))
		((!perceive ?z ?camera)(categorize ?camera))
	)
	
	;; To label the objects
	(:method (label-objects)
		branch1
		(forall (?z) ((object ?z))(labeled ?z))
		nil
		
		branch2
		((object ?z)(not (labeled ?z)))
		((!label-object ?z)(label-objects))
	)
	
	;; To explore the shelves of the cupboard ?c
	(:method (explore-cupboard ?c)
		branch1
		(forall (?z) ((shelf ?z))(labeled ?z))
		nil
		
		branch2
		((shelf ?z)(not (labeled ?z)))
		((!label-shelf ?z)(explore-cupboard ?c))
	)

;; -------------------store-groceries axioms-----------------

	; Characteristics of a snack
	(:- (is-snack ?a)
		((is-bag ?a)(is-crunchy ?a))
	)
	
	; Characteristics of a drink
	(:- (is-drink ?a)
		(or (is-bottle ?a)(is-can ?a))
	)
	
	; Characteristics of a fruit
	(:- (is-fruit ?a)
		((is-round ?a))
	)
			
	)
)
	\end{lstlisting}
	
	
	\subsection{Defining the problem}
	
	A problem file is created for each of the problems to solve. The problem files contain the initial state and the task that the planner has to achieve for solving each problem. The HTN planner uses this information to create a plan based on the domain information. 
	

	\subsection{Problem 1}
	
	\begin{itemize}
		\item The location of the table and the cupboard are known.
		\item There is one known and located object on the table.
		\item The door of the cupboard is closed.
		\item Place the object on any shelf.
	\end{itemize}
	
	\newpage
	
	\subsubsection*{Planning problem}
	
	\begin{lstlisting}
(defproblem problem1 storegroceries
	;;Problem 1
	(
		(object a1)
		(cupboard c1)
		(door d1)
		(shelf s1)
		(table t1)
		(robot r1)
		(on a1 t1) (door-closed d1)(robot-at r1 t1)
	)
	((move-known-object a1 t1 c1 s1))
)
	\end{lstlisting}
	
	\subsubsection*{Generated Plan}
	
	To get the plan, run: \verb|make problem1| \\
	
	Figure \ref{fig:probem1_gui} shows that the the plan is generated in 16 steps. The task is achieved by performing a sequence of 6 primitive tasks: \\
	
	\begin{lstlisting}
[ 1 ]    (!move r1 t1 c1)
[ 2 ]    (!open-door d1)
[ 3 ]    (!move r1 c1 t1)
[ 4 ]    (!pickup a1 t1)
[ 5 ]    (!move r1 t1 c1)
[ 6 ]    (!putdown a1 s1)
	\end{lstlisting}
	
	\subsection{Problem 2}
	
	\begin{itemize}
		\item The table and the cupboard have to be located.
		\item The are $n$ (2 to 5) known and located objects on the table.
		\item The door of the cupboard is closed.
		\item Place the objects on any shelf.
	\end{itemize}
	
	\subsubsection*{Planning problem}
	
	The problem for 5 objects is represented as:
	
	\begin{lstlisting}
(defproblem problem2 storegroceries
	;;Problem2
	(
		(object a1)
		(object a2)
		(object a3)
		(object a4)
		(object a5)
		(cupboard c1)
		(door d1)
		(shelf s1)
		(table t1)
		(robot r1)
		(tray tray1)
		(unknown-location t1)(unknown-location c1)(on a1 t1)(on a2 t1)(on a3 t1)(on a4 t1)(on a5 t1)(door-closed d1)(robot-at r1 t1)
	)
	((move-known-objects t1 c1 s1 tray1))
)
	\end{lstlisting}
	
	\subsubsection*{Generated Plan}
	
	To get the plan, run: \verb|make problem2| \\
	
	Figure \ref{fig:problem2_gui} shows that the the plan is generated in 82 steps. The task is achieved by performing a sequence of 26 primitive tasks: \\
	
	\begin{lstlisting}
	[ 1 ]    (!locate t1)
	[ 2 ]    (!locate c1)
	[ 3 ]    (!move r1 t1 c1)
	[ 4 ]    (!open-door d1)
	[ 5 ]    (!move r1 c1 t1)
	[ 6 ]    (!pickup a1 t1)
	[ 7 ]    (!putdown a1 tray1)
	[ 8 ]    (!pickup a2 t1)
	[ 9 ]    (!putdown a2 tray1)
	[ 10 ]    (!pickup a3 t1)
	[ 11 ]    (!putdown a3 tray1)
	[ 12 ]    (!pickup a4 t1)
	[ 13 ]    (!putdown a4 tray1)
	[ 14 ]    (!pickup a5 t1)
	[ 15 ]    (!putdown a5 tray1)
	[ 16 ]    (!move r1 t1 c1)
	[ 17 ]    (!pickup a1 tray1)
	[ 18 ]    (!putdown a1 s1)
	[ 19 ]    (!pickup a2 tray1)
	[ 20 ]    (!putdown a2 s1)
	[ 21 ]    (!pickup a3 tray1)
	[ 22 ]    (!putdown a3 s1)
	[ 23 ]    (!pickup a4 tray1)
	[ 24 ]    (!putdown a4 s1)
	[ 25 ]    (!pickup a5 tray1)
	[ 26 ]    (!putdown a5 s1)
	\end{lstlisting}
	
	For testing with less objects, the planning problem has to define less objects in the initial state. For instance, for 3 objects, the planning problem is: 
	
	\begin{lstlisting}
(defproblem problem2 storegroceries
	;;Problem2
	(
		(object a1)
		(object a2)
		(object a3)
		(cupboard c1)
		(door d1)
		(shelf s1)
		(table t1)
		(robot r1)
		(tray tray1)
		(unknown-location t1)(unknown-location c1)(on a1 t1)(on a2 t1)(on a3 t1)(door-closed d1)(robot-at r1 t1)
	)
	((move-known-objects t1 c1 s1 tray1))
)
	\end{lstlisting}
	
	The plan is generated in 58 steps and consists of 18 primitive tasks:
	
	\begin{lstlisting}
	[ 1 ]    (!locate t1)
	[ 2 ]    (!locate c1)
	[ 3 ]    (!move r1 t1 c1)
	[ 4 ]    (!open-door d1)
	[ 5 ]    (!move r1 c1 t1)
	[ 6 ]    (!pickup a1 t1)
	[ 7 ]    (!putdown a1 tray1)
	[ 8 ]    (!pickup a2 t1)
	[ 9 ]    (!putdown a2 tray1)
	[ 10 ]    (!pickup a3 t1)
	[ 11 ]    (!putdown a3 tray1)
	[ 12 ]    (!move r1 t1 c1)
	[ 13 ]    (!pickup a1 tray1)
	[ 14 ]    (!putdown a1 s1)
	[ 15 ]    (!pickup a2 tray1)
	[ 16 ]    (!putdown a2 s1)
	[ 17 ]    (!pickup a3 tray1)
	[ 18 ]    (!putdown a3 s1)
	\end{lstlisting}
		
	\subsection{Problem 3}
	
		\begin{itemize}
			\item The table and the cupboard have to be located.
			\item There are $n$ (2 to 5) unknown objects on the table (perception has to be used)
			\item The door of the cupboard is closed.
			\item Place the objects on any shelf.
		\end{itemize}
	
	\subsubsection*{Planning problem}
	
	The problem for 5 objects is represented as:
	
	\begin{lstlisting}
(defproblem problem3 storegroceries
	;;Problem3
	(
		(object a1)
		(object a2)
		(object a3)
		(object a4)
		(object a5)
		(camera camera1)
		(cupboard c1)
		(door d1)
		(shelf s1)
		(table t1)
		(robot r1)
		(tray tray1)
		(unknown-location t1)(unknown-location c1)(on a1 t1)(on a2 t1)(on a3 t1)(on a4 t1)(on a5 t1)(uncategorized a1)(uncategorized a2)(uncategorized a3)(uncategorized a4)(uncategorized a5)(door-closed d1)(robot-at r1 t1)
	)
	((move-uncategorized-objects t1 c1 s1 tray1 camera1))
)
	\end{lstlisting}
	
	\subsubsection*{Generated Plan}
	
	To get the plan, run: \verb|make problem3| \\
	
	Figure \ref{fig:problem3_gui} shows that the the plan for 5 objects is generated in 104 steps. The task is achieved by performing a sequence of 31 primitive tasks: \\
	
	\begin{lstlisting}
[ 1 ]    (!locate t1)
[ 2 ]    (!locate c1)
[ 3 ]    (!perceive a1 camera1)
[ 4 ]    (!perceive a2 camera1)
[ 5 ]    (!perceive a3 camera1)
[ 6 ]    (!perceive a4 camera1)
[ 7 ]    (!perceive a5 camera1)
[ 8 ]    (!move r1 t1 c1)
[ 9 ]    (!open-door d1)
[ 10 ]    (!move r1 c1 t1)
[ 11 ]    (!pickup a1 t1)
[ 12 ]    (!putdown a1 tray1)
[ 13 ]    (!pickup a2 t1)
[ 14 ]    (!putdown a2 tray1)
[ 15 ]    (!pickup a3 t1)
[ 16 ]    (!putdown a3 tray1)
[ 17 ]    (!pickup a4 t1)
[ 18 ]    (!putdown a4 tray1)
[ 19 ]    (!pickup a5 t1)
[ 20 ]    (!putdown a5 tray1)
[ 21 ]    (!move r1 t1 c1)
[ 22 ]    (!pickup a1 tray1)
[ 23 ]    (!putdown a1 s1)
[ 24 ]    (!pickup a2 tray1)
[ 25 ]    (!putdown a2 s1)
[ 26 ]    (!pickup a3 tray1)
[ 27 ]    (!putdown a3 s1)
[ 28 ]    (!pickup a4 tray1)
[ 29 ]    (!putdown a4 s1)
[ 30 ]    (!pickup a5 tray1)
[ 31 ]    (!putdown a5 s1)
	\end{lstlisting}
	
For testing with less objects, the planning problem has to define less objects in the initial state. For instance, for 3 objects, the planning problem is: 

		
	
	\subsection{Problem 4}
	
		\begin{itemize}
			\item The table and the cupboard have to be located.
			\item The cupboard has to be explored. Each shelf holds object of a category.
			\item There are $n$ unknown objects on the table (perception has to be used). Each object belongs to a certain category.
			\item The door of the cupboard is closed.
			\item Place each order on the correct shelf according to the category.
		\end{itemize}
	
	\subsubsection*{Planning problem}
	
	\begin{lstlisting}
(defproblem problem4 storegroceries
	;;Problem4
	(
		(object a1)
		(object a2)
		(object a3)
		(object a4)
		(object a5)
		(camera camera1)
		(cupboard c1)
		(door d1)
		(shelf s1)
		(shelf s2)
		(shelf s3)
		(table t1)
		(robot r1)
		(tray tray1)
		
		(unknown-location t1)(unknown-location c1)(unlabeled c1)
		(holds-snack s1)
		(holds-drink s2)
		(holds-fruit s3)
		(on a1 t1)(is-bag a1)(is-crunchy a1)
		(on a2 t1)(is-bottle a2)
		(on a3 t1)(is-can a3)
		(on a4 t1)(is-round a4)
		(on a5 t1)(is-round a5)
		(door-closed d1)(robot-at r1 t1)
	)
	((move-unlabeled-object-unknown-cupboard t1 c1 s1 tray1 camera1))
)
	\end{lstlisting}
	
	\subsubsection*{Generated Plan}
	
	To get the plan, run: \verb|make problem4| \\
	
	Figure \ref{fig:problem4_gui} shows that the the plan is generated in 118 steps. The task is achieved by performing a sequence of 34 primitive tasks: \\
	
	\begin{lstlisting}
[ 1 ]    (!locate t1)
[ 2 ]    (!locate c1)
[ 3 ]    (!move r1 t1 c1)
[ 4 ]    (!open-door d1)
[ 5 ]    (!label-shelf s1)
[ 6 ]    (!label-shelf s2)
[ 7 ]    (!label-shelf s3)
[ 8 ]    (!move r1 c1 t1)
[ 9 ]    (!label-object a1)
[ 10 ]    (!label-object a2)
[ 11 ]    (!label-object a3)
[ 12 ]    (!label-object a4)
[ 13 ]    (!label-object a5)
[ 14 ]    (!pickup a1 t1)
[ 15 ]    (!putdown a1 tray1)
[ 16 ]    (!pickup a2 t1)
[ 17 ]    (!putdown a2 tray1)
[ 18 ]    (!pickup a3 t1)
[ 19 ]    (!putdown a3 tray1)
[ 20 ]    (!pickup a4 t1)
[ 21 ]    (!putdown a4 tray1)
[ 22 ]    (!pickup a5 t1)
[ 23 ]    (!putdown a5 tray1)
[ 24 ]    (!move r1 t1 c1)
[ 25 ]    (!pickup a1 tray1)
[ 26 ]    (!putdown a1 s1)
[ 27 ]    (!pickup a2 tray1)
[ 28 ]    (!putdown a2 s2)
[ 29 ]    (!pickup a3 tray1)
[ 30 ]    (!putdown a3 s2)
[ 31 ]    (!pickup a4 tray1)
[ 32 ]    (!putdown a4 s3)
[ 33 ]    (!pickup a5 tray1)
[ 34 ]    (!putdown a5 s3)

	\end{lstlisting}
	
	\begin{figure}
		\centering
		\includegraphics[width=1\linewidth]{images/problem1_gui}
		\caption{GUI Problem 1 }
		\label{fig:probem1_gui}
	\end{figure}
		
	\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{images/problem2_gui}
	\caption{GUI Problem 2}
	\label{fig:problem2_gui}
	\end{figure}
	
	\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{images/problem3_gui}
	\caption{GUI Problem 3}
	\label{fig:problem3_gui}
	\end{figure}
	
	
	\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{images/problem4_gui}
	\caption{GUI Problem 4}
	\label{fig:problem4_gui}
	\end{figure}
	
	% TODO
	
	Table compares the number of steps for generating plans for problems 2, 3 and 4 and the number of tasks in the plan, when the number of objects is 2, 3, 4 and 5.
	
	% TODO

	\section{Limitations and Planning Failures} \label{sec:limitations}


	
	\bibliography{bibliography}{}
	\bibliographystyle{plain}
	
	
\end{document}